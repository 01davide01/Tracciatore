<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Segmentazione Colore</title>
  <style>
    /* Layout responsivo */
    body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; }
    .wrapper { position: relative; width: 100%; height: 100%; }
    canvas { width: 100%; height: auto; display: block; }
    /* Pulsante e dropdown */
    #startBtn, #thresholdSelect {
      position: absolute; z-index: 2;
      padding: 10px; font-size: 16px;
      background: rgba(255,255,255,0.8);
      border: none; border-radius: 8px;
      touch-action: manipulation;
    }
    #startBtn { top: 10px; left: 10px; }
    #thresholdSelect { top: 10px; right: 10px; }
    /* Anteprima colore selezionato */
    #colorPreview {
      position: absolute; z-index: 2;
      bottom: 10px; left: 10px;
      width: 50px; height: 50px;
      border: 2px solid #fff;
      background: #000;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <canvas id="canvas"></canvas>
    <button id="startBtn">Avvia Video</button>
    <select id="thresholdSelect"></select>
    <div id="colorPreview"></div>
  </div>

  <script>
  (function() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const thresholdSelect = document.getElementById('thresholdSelect');
    const colorPreview = document.getElementById('colorPreview');

    let video;
    let videoStarted = false;
    let maskActive = false;
    let selectedHSV = null;
    let lowerHSV = null;
    let upperHSV = null;
    let thresholdSec = 3;
    let posHistory = [];
    let fermoDa = null;
    let mirror = false;
    const audio = new Audio('press.wav');
    audio.preload = 'auto';

    const MIN_PIXELS = 1000;

    // Popola dropdown da 1 a 10 secondi
    for (let i = 1; i <= 10; i++) {
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = `${i} s`;
      if (i === thresholdSec) opt.selected = true;
      thresholdSelect.appendChild(opt);
    }
    thresholdSelect.addEventListener('change', () => {
      thresholdSec = parseInt(thresholdSelect.value, 10);
    });

    startBtn.addEventListener('click', async () => {
      if (!videoStarted) {
        await startVideo();
        videoStarted = true;
      } else if (selectedHSV) {
        maskActive = !maskActive;
        if (!maskActive) resetSelection();
      }
    });

    canvas.addEventListener('click', (e) => {
      if (!videoStarted || maskActive) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      const p = ctx.getImageData(x, y, 1, 1).data;
      selectedHSV = rgbToHsv(p[0], p[1], p[2]);
      lowerHSV = [clamp(selectedHSV.h - 20, 0, 360), clamp(selectedHSV.s - 50, 0, 100), clamp(selectedHSV.v - 50, 0, 100)];
      upperHSV = [clamp(selectedHSV.h + 20, 0, 360), clamp(selectedHSV.s + 50, 0, 100), clamp(selectedHSV.v + 50, 0, 100)];
      const prevRgb = hsvToRgb(selectedHSV.h, selectedHSV.s, selectedHSV.v);
      colorPreview.style.background = `rgb(${prevRgb.r},${prevRgb.g},${prevRgb.b})`;
      maskActive = true;
    });

    async function startVideo() {
      video = document.createElement('video');
      video.autoplay = true;
      video.playsInline = true;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });
        const track = stream.getVideoTracks()[0];
        const settings = track.getSettings();
        mirror = settings.facingMode === 'user';
        video.srcObject = stream;
        video.addEventListener('loadedmetadata', () => {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          requestAnimationFrame(loop);
        });
      } catch (e) {
        alert('Impossibile accedere alla videocamera.');
      }
    }

    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (mirror) {
        ctx.save(); ctx.translate(canvas.width, 0); ctx.scale(-1, 1);
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        ctx.restore();
      } else {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      }
      if (maskActive) processFrame();
      requestAnimationFrame(loop);
    }

    function processFrame() {
      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let sumX = 0, sumY = 0, cnt = 0;
      for (let i = 0; i < img.data.length; i += 4) {
        const r = img.data[i], g = img.data[i+1], b = img.data[i+2];
        const hsv = rgbToHsv(r, g, b);
        if (inRange(hsv, lowerHSV, upperHSV)) {
          const idx = i / 4;
          const x = idx % canvas.width;
          const y = Math.floor(idx / canvas.width);
          sumX += x; sumY += y; cnt++;
        } else {
          img.data[i] = img.data[i+1] = img.data[i+2] = 0;
        }
      }
      ctx.putImageData(img, 0, 0);
      if (cnt >= MIN_PIXELS) {
        const cx = sumX / cnt;
        const cy = sumY / cnt;
        ctx.beginPath(); ctx.arc(cx, cy, 10, 0, 2 * Math.PI);
        ctx.lineWidth = 4; ctx.strokeStyle = '#fff'; ctx.stroke();
        posHistory.push(cy);
        if (posHistory.length > 15) posHistory.shift();
        checkFermo();
      } else {
        fermoDa = null;
        posHistory = [];
      }
    }

    function checkFermo() {
      if (posHistory.length < 2) return;
      const delta = Math.max(...posHistory) - Math.min(...posHistory);
      if (delta < 5) {
        if (!fermoDa) fermoDa = Date.now();
        else if ((Date.now() - fermoDa) / 1000 >= thresholdSec) {
          audio.play(); fermoDa = null; posHistory = [];
        }
      } else {
        fermoDa = null;
      }
    }

    function resetSelection() {
      selectedHSV = null;
      lowerHSV = upperHSV = null;
      colorPreview.style.background = '#000';
      posHistory = [];
      fermoDa = null;
    }

    function rgbToHsv(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      const d = max - min;
      let h = 0;
      if (d) {
        if (max === r) h = ((g - b) / d + (g < b ? 6 : 0));
        else if (max === g) h = (b - r) / d + 2;
        else h = (r - g) / d + 4;
        h *= 60;
      }
      const s = max ? (d / max) : 0;
      const v = max;
      return { h: Math.round(h), s: Math.round(s * 100), v: Math.round(v * 100) };
    }

    function hsvToRgb(h, s, v) {
      s /= 100; v /= 100;
      const c = v * s;
      const x = c * (1 - Math.abs((h / 60) % 2 - 1));
      const m = v - c;
      let [r, g, b] = [0, 0, 0];
      if (h < 60) [r, g, b] = [c, x, 0];
      else if (h < 120) [r, g, b] = [x, c, 0];
      else if (h < 180) [r, g, b] = [0, c, x];
      else if (h < 240) [r, g, b] = [0, x, c];
      else if (h < 300) [r, g, b] = [x, 0, c];
      else [r, g, b] = [c, 0, x];
      return { r: Math.round((r + m) * 255), g: Math.round((g + m) * 255), b: Math.round((b + m) * 255) };
    }

    function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }

    function inRange(hsv, lower, upper) {
      return hsv.h >= lower[0] && hsv.h <= upper[0]
          && hsv.s >= lower[1] && hsv.s <= upper[1]
          && hsv.v >= lower[2] && hsv.v <= upper[2];
    }
  })();
  </script>
</body>
</html>





