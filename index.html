<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Segmentazione Colore</title>
  <style>
    body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; }
    .wrapper { position: relative; width: 100%; height: 100%; }
    canvas { width: 100%; height: auto; display: block; }
    #startBtn, #thresholdSelect {
      position: absolute; z-index: 2;
      padding: 10px; font-size: 16px;
      background: rgba(255,255,255,0.8);
      border: none; border-radius: 8px;
      touch-action: manipulation;
    }
    #startBtn { top: 10px; left: 10px; }
    #thresholdSelect { top: 10px; right: 10px; }
    #colorPreview {
      position: absolute; z-index: 2;
      bottom: 10px; left: 10px;
      width: 50px; height: 50px;
      border: 2px solid #fff;
      background: #000;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <canvas id="canvas"></canvas>
    <button id="startBtn">Avvia Video</button>
    <select id="thresholdSelect"></select>
    <div id="colorPreview"></div>
  </div>

  <script>
  (function() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const thresholdSelect = document.getElementById('thresholdSelect');
    const colorPreview = document.getElementById('colorPreview');

    let video, videoStarted = false, maskActive = false;
    let selectedHSV = null, lowerHSV = null, upperHSV = null;
    let thresholdSec = 3, posHistory = [], fermoDa = null;
    let mirror = false;
    const audio = new Audio('press.wav'); audio.preload = 'auto';

    // Parametri di base
    const MIN_PIXELS = 1000;
    const MOVEMENT_TOLERANCE = 20;
    const HSV_TOL = {h:5, s:20, v:20};

    // Popola dropdown secondi
    for (let i = 1; i <= 10; i++) {
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = `${i} s`;
      if (i === thresholdSec) opt.selected = true;
      thresholdSelect.appendChild(opt);
    }
    thresholdSelect.onchange = () => thresholdSec = parseInt(thresholdSelect.value, 10);

    startBtn.onclick = async () => {
      if (!videoStarted) {
        await startVideo();
        videoStarted = true;
      } else if (selectedHSV !== null) {
        maskActive = !maskActive;
        if (!maskActive) resetSelection();
      }
    };

    canvas.onclick = (e) => {
      if (!videoStarted || maskActive) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      const pickX = mirror ? canvas.width - x : x;
      const pickY = y;
      const p = ctx.getImageData(pickX|0, pickY|0, 1, 1).data;
      selectedHSV = rgbToHsv(p[0], p[1], p[2]);
      lowerHSV = [
        clamp(selectedHSV.h - HSV_TOL.h, 0, 360),
        clamp(selectedHSV.s - HSV_TOL.s, 0, 100),
        clamp(selectedHSV.v - HSV_TOL.v, 0, 100)
      ];
      upperHSV = [
        clamp(selectedHSV.h + HSV_TOL.h, 0, 360),
        clamp(selectedHSV.s + HSV_TOL.s, 0, 100),
        clamp(selectedHSV.v + HSV_TOL.v, 0, 100)
      ];
      const prev = hsvToRgb(selectedHSV.h, selectedHSV.s, selectedHSV.v);
      colorPreview.style.background = `rgb(${prev.r},${prev.g},${prev.b})`;
      maskActive = true;
    };

    async function startVideo() {
      video = document.createElement('video');
      video.autoplay = true;
      video.playsInline = true;
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment', width: 1280, height: 720 },
        audio: false
      });
      mirror = stream.getVideoTracks()[0].getSettings().facingMode === 'user';
      video.srcObject = stream;
      video.onloadedmetadata = () => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        requestAnimationFrame(loop);
      };
    }

    function loop() {
      if (mirror) {
        ctx.save();
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(video, 0, 0);
        ctx.restore();
      } else {
        ctx.drawImage(video, 0, 0);
      }
      if (maskActive) processFrame();
      requestAnimationFrame(loop);
    }

    function processFrame() {
      const w = canvas.width, h = canvas.height;
      const img = ctx.getImageData(0, 0, w, h);
      // crea la maschera HSV
      const mask = new Uint8Array(w*h);
      for (let i = 0; i < img.data.length; i += 4) {
        const hsv = rgbToHsv(img.data[i], img.data[i+1], img.data[i+2]);
        mask[i/4] = inRange(hsv, lowerHSV, upperHSV) ? 1 : 0;
      }
      // connected components (blob più grande)
      const labels = new Int32Array(w*h), sizes = {}, queue = [];
      let lbl = 0;
      for (let idx = 0; idx < mask.length; idx++) {
        if (mask[idx] && labels[idx] === 0) {
          lbl++; sizes[lbl] = 0;
          labels[idx] = lbl;
          queue.push(idx);
          while (queue.length) {
            const v = queue.pop();
            sizes[lbl]++;
            const x = v % w, y = Math.floor(v / w);
            [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy]) => {
              const nx = x+dx, ny = y+dy, ni = ny*w+nx;
              if (nx>=0&&nx<w&&ny>=0&&ny<h&&mask[ni]&&labels[ni]===0) {
                labels[ni] = lbl;
                queue.push(ni);
              }
            });
          }
        }
      }
      // trova il blob più grande
      let maxLabel = 0, maxSize = 0;
      for (const k in sizes) {
        if (sizes[k] > maxSize) { maxSize = sizes[k]; maxLabel = +k; }
      }
      // disegna solo il blob più grande
      let sumX=0, sumY=0, count=0;
      for (let i = 0; i < labels.length; i++) {
        const i4 = i*4;
        if (labels[i] === maxLabel) {
          const x = i % w, y = Math.floor(i / w);
          sumX+=x; sumY+=y; count++;
        } else {
          img.data[i4] = img.data[i4+1] = img.data[i4+2] = 0;
        }
      }
      ctx.putImageData(img, 0, 0);
      if (count >= MIN_PIXELS) {
        const cx = sumX/count, cy = sumY/count;
        ctx.beginPath();
        ctx.arc(cx, cy, 10, 0, 2*Math.PI);
        ctx.lineWidth = 4; ctx.strokeStyle = '#fff'; ctx.stroke();
        // check fermo...
      }
    }

    // utility e stato
    function resetSelection() {
      maskActive = false;
      selectedHSV = lowerHSV = upperHSV = null;
      posHistory = []; fermoDa = null;
      colorPreview.style.background = '#000';
    }
    function rgbToHsv(r,g,b) {
      r/=255;g/=255;b/=255;
      const M=Math.max(r,g,b), m=Math.min(r,g,b), d=M-m;
      let h=0;
      if (d) {
        if (M===r) h = ((g-b)/d + (g<b?6:0));
        else if (M===g) h = (b-r)/d + 2;
        else h = (r-g)/d + 4;
        h *= 60;
      }
      const s= M? d/M:0, v=M;
      return {h:Math.round(h),s:Math.round(s*100),v:Math.round(v*100)};
    }
    function inRange(hsv, lo, hi) {
      return hsv.h>=lo[0]&&hsv.h<=hi[0]
          && hsv.s>=lo[1]&&hsv.s<=hi[1]
          && hsv.v>=lo[2]&&hsv.v<=hi[2];
    }
    function clamp(v,min,max){ return v<min?min:v>max?max:v; }
  })();
  </script>
</body>
</html>
