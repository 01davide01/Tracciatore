<!DOCTYPE html><html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Segmentazione Colore</title>
  <style>
    body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; }
    .wrapper { position: relative; width: 100%; height: 100%; }
    canvas { width: 100%; height: auto; display: block; }
    #startBtn, #thresholdSelect {
      position: absolute; z-index: 2;
      padding: 10px; font-size: 16px;
      background: rgba(255,255,255,0.8);
      border: none; border-radius: 8px;
      touch-action: manipulation;
    }
    #startBtn { top: 10px; left: 10px; }
    #thresholdSelect { top: 10px; right: 10px; }
    #colorPreview {
      position: absolute; z-index: 2;
      bottom: 10px; left: 10px;
      width: 50px; height: 50px;
      border: 2px solid #fff;
      background: #000;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <canvas id="canvas"></canvas>
    <button id="startBtn">Avvia Video</button>
    <select id="thresholdSelect"></select>
    <div id="colorPreview"></div>
  </div>  <script>
  (function() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const thresholdSelect = document.getElementById('thresholdSelect');
    const colorPreview = document.getElementById('colorPreview');

    let video, videoStarted = false, maskActive = false;
    let selectedHSV = null, lowerHSV = null, upperHSV = null;
    let thresholdSec = 3, posHistory = [], fermoDa = null;
    let mirror = false;
    const audio = new Audio('press.wav'); audio.preload = 'auto';

    const MIN_PIXELS = 2000;
    const MOVEMENT_TOLERANCE = 20;
    const OPENING_RADIUS = 2;
    const HSV_TOL = { h: 5, s: 20, v: 20 };

    for (let i = 1; i <= 10; i++) {
      const opt = document.createElement('option'); opt.value = i; opt.textContent = `${i} s`;
      if (i === thresholdSec) opt.selected = true;
      thresholdSelect.appendChild(opt);
    }
    thresholdSelect.addEventListener('change', () => thresholdSec = parseInt(thresholdSelect.value, 10));

    startBtn.addEventListener('click', async () => {
      if (!videoStarted) { await startVideo(); videoStarted = true; }
      else if (selectedHSV !== null) { maskActive = !maskActive; if (!maskActive) resetSelection(); }
    });

    canvas.addEventListener('click', e => {
      if (!videoStarted || maskActive) return;
      const rect = canvas.getBoundingClientRect();
      const rawX = (e.clientX - rect.left) * (canvas.width / rect.width);
      const rawY = (e.clientY - rect.top) * (canvas.height / rect.height);
      const pickX = mirror ? canvas.width - rawX : rawX;
      const pickY = rawY;
      const p = ctx.getImageData(Math.round(pickX), Math.round(pickY), 1, 1).data;
      selectedHSV = rgbToHsv(p[0], p[1], p[2]);
      lowerHSV = [ clamp(selectedHSV.h - HSV_TOL.h, 0, 360), clamp(selectedHSV.s - HSV_TOL.s, 0, 100), clamp(selectedHSV.v - HSV_TOL.v, 0, 100) ];
      upperHSV = [ clamp(selectedHSV.h + HSV_TOL.h, 0, 360), clamp(selectedHSV.s + HSV_TOL.s, 0, 100), clamp(selectedHSV.v + HSV_TOL.v, 0, 100) ];
      const prev = hsvToRgb(selectedHSV.h, selectedHSV.s, selectedHSV.v);
      colorPreview.style.background = `rgb(${prev.r},${prev.g},${prev.b})`;
      maskActive = true;
    });

    async function startVideo() {
      video = document.createElement('video'); video.autoplay = true; video.playsInline = true;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:'environment'},width:{ideal:1280},height:{ideal:720}},audio:false});
        const track = stream.getVideoTracks()[0]; mirror = track.getSettings().facingMode === 'user';
        video.srcObject = stream;
        video.addEventListener('loadedmetadata', () => { canvas.width = video.videoWidth; canvas.height = video.videoHeight; requestAnimationFrame(loop); });
      } catch (e) { alert('Impossibile accedere alla videocamera.'); }
    }

    function loop() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (mirror) { ctx.save(); ctx.translate(canvas.width,0); ctx.scale(-1,1); ctx.drawImage(video,0,0); ctx.restore(); }
      else ctx.drawImage(video,0,0);
      if (maskActive) processFrame();
      requestAnimationFrame(loop);
    }

    function processFrame() {
      const w = canvas.width, h = canvas.height;
      const img = ctx.getImageData(0,0,w,h);
      const mask = new Uint8Array(w*h);
      for (let i=0;i<img.data.length;i+=4) {
        const idx=i/4;
        const hsv = rgbToHsv(img.data[i],img.data[i+1],img.data[i+2]);
        mask[idx] = inRange(hsv,lowerHSV,upperHSV)?1:0;
      }
      const opened = opening(mask,w,h,OPENING_RADIUS);
      // label connected components
      const labels = new Int32Array(w*h);
      const sizes = {};
      let label=0;
      for (let idx=0;idx<opened.length;idx++){
        if (opened[idx] && labels[idx]===0){
          label++; sizes[label]=0;
          const queue=[idx]; labels[idx]=label;
          while(queue.length){
            const v=queue.pop(); sizes[label]++;
            const x=v%w, y=Math.floor(v/w);
            [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
              const nx=x+dx, ny=y+dy;
              if (nx>=0&&nx<w&&ny>=0&&ny<h){
                const ni=ny*w+nx;
                if (opened[ni] && labels[ni]===0){ labels[ni]=label; queue.push(ni);} }
            });
          }
        }
      }
      // find largest label
      let maxLabel=0, maxSize=0;
      for(const k in sizes) if(sizes[k]>maxSize){maxSize=sizes[k];maxLabel=parseInt(k);}      
      // draw only largest component
      let sumX=0,sumY=0,count=0;
      for(let idx=0;idx<labels.length;idx++){
        const i4=idx*4;
        if(labels[idx]!==maxLabel){ img.data[i4]=img.data[i4+1]=img.data[i4+2]=0; }
        else{ const x=idx%w, y=Math.floor(idx/w); sumX+=x; sumY+=y; count++; }
      }
      ctx.putImageData(img,0,0);
      if(count>=MIN_PIXELS){
        const cx=sumX/count, cy=sumY/count;
        ctx.beginPath(); ctx.arc(cx,cy,10,0,2*Math.PI); ctx.lineWidth=4; ctx.strokeStyle='#fff'; ctx.stroke();
        posHistory.push(cy); if(posHistory.length>15) posHistory.shift();
        checkFermo(posHistory);
      } else { fermoDa=null; posHistory=[]; }
    }

    function opening(mask,w,h,r){ let temp=new Uint8Array(mask), res=new Uint8Array(mask.length);
      for(let y=r;y<h-r;y++)for(let x=r;x<w-r;x++){ const i=y*w+x; let ok=true; for(let dy=-r;dy<=r;dy++)for(let dx=-r;dx<=r;dx++){ if(!mask[(y+dy)*w+(x+dx)]){ok=false;break;} } temp[i]=ok?1:0; }
      for(let y=r;y<h-r;y++)for(let x=r;x<w-r;x++){ const i=y*w+x; let ok=false; for(let dy=-r;dy<=r;dy++)for(let dx=-r;dx<=r;dx++){ if(temp[(y+dy)*w+(x+dx)]){ok=true;break;} } res[i]=ok?1:0; }
      return res; }

    function checkFermo(history){ const delta=Math.max(...history)-Math.min(...history);
      if(delta<=MOVEMENT_TOLERANCE){ if(!fermoDa) fermoDa=Date.now(); else if((Date.now()-fermoDa)/1000>=thresholdSec){ audio.play(); fermoDa=null; posHistory=[];} }
      else fermoDa=null;
    }

    function resetSelection(){ selectedHSV=null; lowerHSV=upperHSV=null; colorPreview.style.background='#000'; posHistory=[]; fermoDa=null; }
    function rgbToHsv(r,g,b){r/=255;g/=255;b/=255;const M=Math.max(r,g,b),m=Math.min(r,g,b),d=M-m;let h=0;if(d){if(M===r)h=((g-b)/d+(g<b?6:0));else if(M===g)h=(b-r)/d+2;else h=(r-g)/d+4;h*=60;}return {h:Math.round(h),s:Math.round((M?d/M:0)*100),v:Math.round(M*100)};}
    function inRange(hsv,l,u){return hsv.h>=l[0]&&hsv.h<=u[0]&&hsv.s>=l[1]&&hsv.s<=u[1]&&hsv.v>=l[2]&&hsv.v<=u[2];}
    function clamp(v,min,max){return v<min?min:v>max?max:v;}
  })();
  </script></body>
</html>
