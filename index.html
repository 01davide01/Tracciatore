<!DOCTYPE html><html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Tracciatore Colore</title>
  <style>
    body, html { margin:0; padding:0; width:100%; height:100%; background:#000; overflow:hidden; }
    #canvas { display:block; width:100%; height:auto; }
    #controls { position:absolute; top:10px; left:10px; right:10px; display:flex; justify-content:space-between; z-index:2; }
    button, select { padding:10px; font-size:16px; background:rgba(255,255,255,0.8); border:none; border-radius:8px; touch-action:manipulation; }
    #colorPreview { position:absolute; bottom:10px; left:10px; width:50px; height:50px; border:2px solid #fff; border-radius:4px; background:#000; z-index:2; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="controls">
    <button id="btn">Avvia Video</button>
    <select id="sel"></select>
  </div>
  <div id="colorPreview"></div>  <script>
  (function(){
    const canvas=document.getElementById('canvas'), ctx=canvas.getContext('2d'),
          btn=document.getElementById('btn'), sel=document.getElementById('sel'),
          preview=document.getElementById('colorPreview'), audio=new Audio('press.wav');
    audio.preload='auto';

    let video, started=false, maskOn=false,
        hsvSel=null, lower, upper,
        history=[], stillStart=null, under=0, initSize=null;

    const MIN_PIX=500, MOVTOL=20, OPENR=2,
          HSVR={h:5,s:20,v:20}, MAXUNDER=5;

    // popola dropdown secondi
    for(let i=1;i<=10;i++){const o=document.createElement('option');o.value=i;o.textContent=`${i}s`;if(i===3)o.selected=true;sel.append(o);}    

    btn.onclick=async()=>{
      if(!started){ await startCam(); started=true; btn.textContent='Reset'; }
      else resetAll();
    };

    // selezione colore solo se non in maschera
    canvas.onclick = e => {
      if (!started || maskOn) return;
      const r = canvas.getBoundingClientRect(),
            x = ((e.clientX - r.left) * canvas.width / r.width) | 0,
            y = ((e.clientY - r.top)  * canvas.height / r.height) | 0,
            px = mirror ? canvas.width - x : x, py = y,
            d = ctx.getImageData(px, py, 1, 1).data;
      hsvSel = rgbToHsv(d[0], d[1], d[2]);
      lower = [
        clamp(hsvSel.h - HSVR.h, 0, 360),
        clamp(hsvSel.s - HSVR.s, 0, 100),
        clamp(hsvSel.v - HSVR.v, 0, 100)
      ];
      upper = [
        clamp(hsvSel.h + HSVR.h, 0, 360),
        clamp(hsvSel.s + HSVR.s, 0, 100),
        clamp(hsvSel.v + HSVR.v, 0, 100)
      ];
      const c = hsvToRgb(hsvSel.h, hsvSel.s, hsvSel.v);
      preview.style.background = `rgb(${c.r},${c.g},${c.b})`;
      maskOn = true; under = 0; initSize = null;
      // unlock audio on mobile
      audio.play().catch(()=>{}); audio.pause(); audio.currentTime = 0;
    }; // disabilita click sulla maschera
      // unlock audio
      audio.play().catch(()=>{}); audio.pause(); audio.currentTime=0;
    };

    let mirror=false;
    async function startCam(){
      video=document.createElement('video'); video.autoplay=true; video.playsInline=true;
      const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment',width:1280,height:720},audio:false});
      mirror=s.getVideoTracks()[0].getSettings().facingMode==='user';
      video.srcObject=s;
      video.onloadedmetadata=()=>{canvas.width=video.videoWidth;canvas.height=video.videoHeight;requestAnimationFrame(loop);}    
    }

    function loop(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(mirror){ctx.save();ctx.translate(canvas.width,0);ctx.scale(-1,1);ctx.drawImage(video,0,0);ctx.restore();}
      else ctx.drawImage(video,0,0);
      if(maskOn) track();
      requestAnimationFrame(loop);
    }

    function track() {
      const w = canvas.width, h = canvas.height;
      const img = ctx.getImageData(0, 0, w, h);
      const mask = new Uint8Array(w * h);
      for (let i = 0; i < img.data.length; i += 4) {
        const hsv = rgbToHsv(img.data[i], img.data[i + 1], img.data[i + 2]);
        mask[i / 4] = inRange(hsv, lower, upper) ? 1 : 0;
      }
      const op = opening(mask, w, h, OPENR);
      const {labels, sizes} = labelCC(op, w, h);
      let bigL = 0, bigSz = 0;
      for (const l in sizes) if (sizes[l] > bigSz) { bigSz = sizes[l]; bigL = +l; }
      if (initSize === null) initSize = bigSz;
      const dynMin = Math.max(MIN_PIX, initSize * 0.2);
      if (bigSz < dynMin) {
        // blob temporaneamente assente: mantieni selezione e preview
        return;
      }
      // valid blob: procedi al tracciamento
      let sumX = 0, sumY = 0, cnt = 0;
      for (let i = 0; i < labels.length; i++) {
        const i4 = i * 4;
        if (labels[i] === bigL) {
          const x = i % w, y = (i / w) | 0;
          sumX += x; sumY += y; cnt++;
        } else {
          img.data[i4] = img.data[i4 + 1] = img.data[i4 + 2] = 0;
        }
      }
      ctx.putImageData(img, 0, 0);
      const cx = sumX / cnt, cy = sumY / cnt;
      ctx.beginPath(); ctx.arc(cx, cy, 10, 0, 2 * Math.PI);
      ctx.lineWidth = 4; ctx.strokeStyle = '#fff'; ctx.stroke();
      history.push(cy); if (history.length > 15) history.shift();
      checkStill();
    }
      let sumX=0,sumY=0,cnt=0;
      for(let i=0;i<labels.length;i++){const i4=i*4;if(labels[i]===bigL){const x=i%w,y=(i/w)|0;sumX+=x;sumY+=y;cnt++;}else img.data[i4]=img.data[i4+1]=img.data[i4+2]=0;}
      ctx.putImageData(img,0,0);
      const cx=sumX/cnt,cy=sumY/cnt;
      ctx.beginPath();ctx.arc(cx,cy,10,0,2*Math.PI);ctx.lineWidth=4;ctx.strokeStyle='#fff';ctx.stroke();
      history.push(cy);if(history.length>15)history.shift();checkStill();
    }

    function checkStill(){const t=parseInt(sel.value,10)*1e3,d=Math.max(...history)-Math.min(...history);
      if(d<=MOVTOL){if(!stillStart)stillStart=Date.now();else if(Date.now()-stillStart>=t){audio.play().catch(()=>{});stillStart=null;history=[];}}else stillStart=null;}    
    function resetAll(){
      canvas.style.pointerEvents = 'auto'; // riabilita click su canvasmaskOn=false;hsvSel=null;history=[];stillStart=null;under=0;initSize=null;preview.style.background='#000';btn.textContent='Avvia Video';}

    // helpers: opening,labelCC,rgbToHsv,hsvToRgb,inRange,clamp (unchanged)...
    function opening(m,w,h,r){const t=new Uint8Array(m),res=new Uint8Array(m.length);for(let y=r;y<h-r;y++)for(let x=r;x<w-r;x++){const i=y*w+x;let ok=true;for(let dy=-r;dy<=r&&ok;dy++)for(let dx=-r;dx<=r;dx++)if(!m[(y+dy)*w+(x+dx)])ok=false;t[i]=ok?1:0;}for(let y=r;y<h-r;y++)for(let x=r;x<w-r;x++){const i=y*w+x;let ok=false;for(let dy=-r;dy<=r&&!ok;dy++)for(let dx=-r;dx<=r;dx++)if(t[(y+dy)*w+(x+dx)])ok=true;res[i]=ok?1:0;}return res;}
    function labelCC(m,w,h){const labels=new Int32Array(m.length),sizes={},q=[];let l=0;for(let i=0;i<m.length;i++)if(m[i]&&labels[i]===0){l++;sizes[l]=0;labels[i]=l;q.push(i);while(q.length){const v=q.pop();sizes[l]++;const x=v%w,y=(v/w)|0;[[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{const nx=x+dx,ny=y+dy,ni=ny*w+nx;if(nx>=0&&nx<w&&ny>=0&&ny<h&&m[ni]&&labels[ni]===0){labels[ni]=l;q.push(ni);}});} }return{labels,sizes};}
    function rgbToHsv(r,g,b){r/=255;g/=255;b/=255;const M=Math.max(r,g,b),m=Math.min(r,g,b),d=M-m;let h=0;if(d){if(M===r)h=((g-b)/d+(g<b?6:0));else if(M===g)h=(b-r)/d+2;else h=(r-g)/d+4;h*=60;}return{h:Math.round(h),s:Math.round((M?d/M:0)*100),v:Math.round(M*100)};}
    function hsvToRgb(h,s,v){s/=100;v/=100;const c=v*s,x=c*(1-Math.abs((h/60)%2-1)),m=v-c;let r=0,g=0,b=0;if(h<60)[r,g,b]=[c,x,0];else if(h<120)[r,g,b]=[x,c,0];else if(h<180)[r,g,b]=[0,c,x];else if(h<240)[r,g,b]=[0,x,c];else if(h<300)[r,g,b]=[x,0,c];else[r,g,b]=[c,0,x];return{r:Math.round((r+m)*255),g:Math.round((g+m)*255),b:Math.round((b+m)*255)};}
    function inRange(h,lo,hi){return h.h>=lo[0]&&h.h<=hi[0]&&h.s>=lo[1]&&h.s<=hi[1]&&h.v>=lo[2]&&h.v<=hi[2];}
    function clamp(v,mi,ma){return v<mi?mi:v>ma?ma:v;}
  })();
  </script></body>
</html>
