<!DOCTYPE html><html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Segmentazione Colore</title>
  <style>
    body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; }
    .wrapper { position: relative; width: 100%; height: 100%; }
    canvas { width: 100%; height: auto; display: block; }
    #startBtn, #thresholdSelect {
      position: absolute; z-index: 2;
      padding: 10px; font-size: 16px;
      background: rgba(255,255,255,0.8);
      border: none; border-radius: 8px;
      touch-action: manipulation;
    }
    #startBtn { top: 10px; left: 10px; }
    #thresholdSelect { top: 10px; right: 10px; }
    #colorPreview {
      position: absolute; z-index: 2;
      bottom: 10px; left: 10px;
      width: 50px; height: 50px;
      border: 2px solid #fff;
      background: #000;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <canvas id="canvas"></canvas>
    <button id="startBtn">Avvia Video</button>
    <select id="thresholdSelect"></select>
    <div id="colorPreview"></div>
  </div>  <script>
  (function() {
    const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const thresholdSelect = document.getElementById('thresholdSelect');
    const colorPreview = document.getElementById('colorPreview');

    let video, videoStarted=false, maskActive=false;
    let selectedHSV=null, lowerHSV=null, upperHSV=null;
    let thresholdSec=3, posHistory=[], fermoDa=null;
    let mirror=false;
    const audio = new Audio('press.wav'); audio.preload='auto';

    const MIN_PIXELS = 500;               // soglia minima blob
    const MOVEMENT_TOLERANCE = 20;
    const OPENING_RADIUS = 2;
    const HSV_TOL = { h: 5, s: 20, v: 20 };
    const MAX_UNDER = 5;                  // frame sotto soglia tollerati
    let underThresholdCount = 0;
    let initialBlobCount = null;

    for(let i=1;i<=10;i++){ const opt=document.createElement('option'); opt.value=i; opt.textContent=`${i} s`; if(i===thresholdSec)opt.selected=true; thresholdSelect.appendChild(opt);}    
    thresholdSelect.onchange=()=>thresholdSec=parseInt(thresholdSelect.value,10);

    startBtn.onclick=async()=>{
      if(!videoStarted){ await startVideo(); videoStarted=true; }
      else if(selectedHSV!==null){ maskActive=!maskActive; if(!maskActive)resetSelection(); }
    };

    canvas.onclick=e=>{
      if(!videoStarted||maskActive)return;
      const rect=canvas.getBoundingClientRect();
      const rawX=(e.clientX-rect.left)*(canvas.width/rect.width);
      const rawY=(e.clientY-rect.top)*(canvas.height/rect.height);
      const pickX=mirror?canvas.width-rawX:rawX, pickY=rawY;
      const p=ctx.getImageData(Math.round(pickX),Math.round(pickY),1,1).data;
      selectedHSV=rgbToHsv(p[0],p[1],p[2]);
      lowerHSV=[clamp(selectedHSV.h-HSV_TOL.h,0,360),clamp(selectedHSV.s-HSV_TOL.s,0,100),clamp(selectedHSV.v-HSV_TOL.v,0,100)];
      upperHSV=[clamp(selectedHSV.h+HSV_TOL.h,0,360),clamp(selectedHSV.s+HSV_TOL.s,0,100),clamp(selectedHSV.v+HSV_TOL.v,0,100)];
      colorPreview.style.background=`rgb(${hsvToRgb(selectedHSV.h,selectedHSV.s,selectedHSV.v).r},${hsvToRgb(selectedHSV.h,selectedHSV.s,selectedHSV.v).g},${hsvToRgb(selectedHSV.h,selectedHSV.s,selectedHSV.v).b})`;
      maskActive=true; underThresholdCount=0; initialBlobCount=null;
    };

    async function startVideo(){
      video=document.createElement('video'); video.autoplay=true; video.playsInline=true;
      try{
        const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:'environment'},width:{ideal:1280},height:{ideal:720}},audio:false});
        const track=stream.getVideoTracks()[0]; mirror=track.getSettings().facingMode==='user';
        video.srcObject=stream; video.onloadedmetadata=()=>{ canvas.width=video.videoWidth; canvas.height=video.videoHeight; requestAnimationFrame(loop); };
      }catch(e){ alert('Impossibile accedere alla videocamera.'); }
    }

    function loop(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(mirror){ ctx.save(); ctx.translate(canvas.width,0); ctx.scale(-1,1); ctx.drawImage(video,0,0); ctx.restore(); }
      else ctx.drawImage(video,0,0);
      if(maskActive)processFrame();
      requestAnimationFrame(loop);
    }

    function processFrame(){
      const w=canvas.width, h=canvas.height;
      const img=ctx.getImageData(0,0,w,h);
      const mask=new Uint8Array(w*h);
      for(let i=0;i<img.data.length;i+=4){ const hsv=rgbToHsv(img.data[i],img.data[i+1],img.data[i+2]); mask[i/4]=inRange(hsv,lowerHSV,upperHSV)?1:0; }
      const opened=opening(mask,w,h,OPENING_RADIUS);
      // label components
      const labels=new Int32Array(w*h), sizes={}; let label=0;
      for(let idx=0;idx<opened.length;idx++){
        if(opened[idx]&&labels[idx]===0){ label++; sizes[label]=0;
          const queue=[idx]; labels[idx]=label;
          while(queue.length){ const v=queue.pop(); sizes[label]++; const x=v%w,y=Math.floor(v/w);
            [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{ const ni=(y+dy)*w+(x+dx);
              if(x+dx>=0&&x+dx<w&&y+dy>=0&&y+dy<h&&opened[ni]&&labels[ni]===0){ labels[ni]=label; queue.push(ni);} });
          }
        }
      }
      // find largest
      let maxLabel=0, maxSize=0;
      for(const k in sizes) if(sizes[k]>maxSize){maxSize=sizes[k];maxLabel=+k;}
      if(initialBlobCount===null) initialBlobCount=maxSize;
      const dynamicMin=Math.max(MIN_PIXELS, initialBlobCount*0.2);
      // build blobMask
      const blobMask=new Uint8Array(w*h);
      let sumX=0,sumY=0,count=0;
      for(let i=0;i<labels.length;i++){
        if(labels[i]===maxLabel){ blobMask[i]=1; const x=i%w,y=Math.floor(i/w); sumX+=x; sumY+=y; count++; }
      }
      if(count<dynamicMin){ underThresholdCount++; if(underThresholdCount>=MAX_UNDER) resetSelection(); return; }
      underThresholdCount=0;
      const cx=sumX/count, cy=sumY/count;
      const rMax=computeMaxCircleRadius(blobMask,cx,cy,w,h,Math.max(w,h));
      // render final circle mask
      let sum2X=0,sum2Y=0,count2=0;
      for(let i=0;i<blobMask.length;i++){
        const x=i%w,y=Math.floor(i/w); const dx=x-cx,dy=y-cy;
        if(blobMask[i]&&dx*dx+dy*dy<=rMax*rMax){ sum2X+=x; sum2Y+=y; count2++; }
        else{ const p=i*4; img.data[p]=img.data[p+1]=img.data[p+2]=0; }
      }
      ctx.putImageData(img,0,0);
      if(count2>=dynamicMin){ const rcx=sum2X/count2, rcy=sum2Y/count2;
        ctx.beginPath(); ctx.arc(rcx,rcy,10,0,2*Math.PI); ctx.lineWidth=4; ctx.strokeStyle='#fff'; ctx.stroke();
        posHistory.push(rcy); if(posHistory.length>15)posHistory.shift(); checkFermo(); }
      else{ underThresholdCount++; if(underThresholdCount>=MAX_UNDER) resetSelection(); }
    }

    function computeMaxCircleRadius(mask,cx,cy,w,h,maxR){ let r=0,step=10*Math.PI/180;
      while(r<maxR){ const nextR=r+1; let found=false;
        for(let a=0;a<2*Math.PI;a+=step){ const x=Math.round(cx+nextR*Math.cos(a)),y=Math.round(cy+nextR*Math.sin(a));
          if(x>=0&&x<w&&y>=0&&y<h&&mask[y*w+x]){ found=true; break; }}
        if(found) r=nextR; else break;
      }
      return r;
    }
    function opening(mask,w,h,r){ let temp=new Uint8Array(mask),res=new Uint8Array(mask.length);
      for(let y=r;y<h-r;y++)for(let x=r;x<w-r;x++){ const i=y*w+x; let ok=true;
        for(let dy=-r;dy<=r&&ok;dy++)for(let dx=-r;dx<=r;dx++)if(!mask[(y+dy)*w+(x+dx)]){ok=false;break;}
        temp[i]=ok?1:0; }
      for(let y=r;y<h-r;y++)for(let x=r;x<w-r;x++){ const i=y*w+x; let ok=false;
        for(let dy=-r;dy<=r&&!ok;dy++)for(let dx=-r;dx<=r;dx++)if(temp[(y+dy)*w+(x+dx)]){ok=true;break;}
        res[i]=ok?1:0;} return res; }
    function checkFermo(){ const delta=Math.max(...posHistory)-Math.min(...posHistory);
      if(delta<=MOVEMENT_TOLERANCE){ if(!fermoDa)fermoDa=Date.now(); else if((Date.now()-fermoDa)/1000>=thresholdSec){audio.play();fermoDa=null;posHistory=[];} }
      else fermoDa=null; }
    function resetSelection(){ selectedHSV=null; lowerHSV=upperHSV=null; colorPreview.style.background='#000'; posHistory=[]; fer... remainder omitted for brevity
